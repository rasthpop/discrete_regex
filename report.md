## Звіт - regex.py

### Задача
Regex.py передбачає написати власний компайлер для регулярних виразів, використовуючи Скінченні автомати, які, власне, і перевіряють стрічку на візерунок.

### Основні Компоненти
Основним класом є `RegexFSM` - що в першу чергу ітерується по регулярному виразі. 

#### Класи

- `StartState` - Початковий стан, задається при ініціалізації основного класу.

- `AsciiState` - Базовий стан, який перевіряє стрічку на наявність певного **ASCII** символу.

- `DotState` - Стан, який працює на основі `AsciiState`, але приймає будь-який символ.

- `StarState` - Особливий стан, який приймає `AsciiState` чи `DotState` і приймає 0 або $\infty$ символів даного стану у рядку. Перевірка відбувається використовуючи атрибут *checking_state*. Також цей стан має атрибут *prev_state*, що посилається на попередній стан.

- `PlusState` - Стан дещо схожий до `StarState`, проте очікує як мінімум один символ, що перевіряється. Він складається з *checking_state* і *loop_state*. Приймаючи сиволи зі стрічку, яку перевіряє компілятор, спочатку очікується символ з *checking_state*, у разі співпадіння атрибут *minimum_check* стає `True`, далі у цьоум стані вже буде працювати стан зірочки, який приймає довільну кількість цього символу.

- `TerminationState` - Елімінаційний стан, який використовується у разі відхилення стрічки, а в нашому контексті відхилення символу станом. Ця валідація символу проходить у методі `check_self`.

#### Методи

- `check_self` - Перевіряє атрибут символу класу та символ, який дається на вхід, повертає `True`, якщо вони рівні, інакше `False`.

- `check_next` - Перевіряє наступні стани  даного стану використовуючи наступний символ, якщо умова задовільняється, тоді функція повертає відповідний стан, якщо символ не підійшов під жоден можливий стан, то повертається `TerminationState`, що фактично стверджує, що стрічка не підходить під регулярний вираз.


Основна стрічка перевіряється у методі класу `RegexFSM` під назвою `check_string`.
### Принцип Роботи

Ініціалізується клас `RegexFSM`, де формується скінченний автомат залежно від регулярного виразу:

- Починаємо у стані Start, ініціалізуємо prev_state, tmp_next_state та states.

- Для всіх наступних символів запускається метод `__init_next_state`, який повертає стан, створений для відповідного символу. У разі стандартного ASCII символу створюємо AsciiState і додаємо його у next_states даного стану і також у загальний список всіх станів - states. Також, оскільки цей алгоритм створення скінченного автомата жадібний, ми перевіряємо наступний символ, якщо він є у стрічці і дорівнює `*` або `+`. Якщо ця умова виконується, то ми створюємо `StarState` чи `PlusState` відповідно. У checking_state задаємо AsciiState або DotState. Наступний стан після `StarState` ми додаємо до наступних станів попередника стану *, оскільки автомат повинен мати перехід, який обходить "\*" (0 оказій даного символу). У алгоритмі є перевірка на `isinstance`, після чого такий функціонал виконується у разі задовільної умови. 

 - Після завершення ітерації регулярного виразу, ми ітеруємось по станах у зворотньому порядку, як ми їх додавали, які у нас є та позначаємо кінцеві стани. Кінцевий стан позначається атрибутом у відповідному стані, задаючи `is_end` = `True`. Якщо останній стан - `StarState`, тоді ми перевіряємо попередній до нього, оскільки для * може бути 0 символів.


 Далі для перевірки стрічки запускаємо метод `check_string`. Починаємо у початковому стані та ітеруємось по кожному символу стрічки. Наперед маємо референс на початок. У кожній ітерації перехимо у інший стан або зациклюємось у разі * чи +, це перевіряється за допомогою `check_next`. Для `PlusState` врахована дещо інша поведінка. Якщо у є стан `.+`, то запускається цикл на перевірку деякої ключової фрази, опираючись на наступні стани. Ця поведінка не є зовсім коректна, оскільки вона не врахує деякі edge кейси, але я старався)). Отже якщо у стрічці наступні пару символів співпадають з тою фразою, то ми переходимо у інший стан. Після завершення циклу перевіряємо чи стан у якому ми наразі перебуваємо є кінцевим (TerminationState завжди має атрибут is_end заданий як `False`). також задаємо поточний стан назад на початковий за допомогою референсу, який ми задали на початку, щоб компілятор працював для наступних стрічок. Функція повертає булеве значення, яке означає чи прочитав автомат цю стрічку, чи ні.   

